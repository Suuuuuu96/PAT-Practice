//基于分桶法的平方分割、效率略低 https://pintia.cn/problem-sets/994805342720868352/problems/994805417945710592
#include<cstdio>
#include<cmath>
#include<vector>
using namespace std;
int main()
{
	int n,i,te,max=0,m=0,j,k,l,g,r,mid,find,sum;
	scanf("%d",&n);
	vector<int> ve(1,0);
	vector<int> re;
	vector<int> fi;
	char str[11];
	for(i=1;i<=n;i++)
	{
		scanf("%s",str);
		if(str[1]=='o')
		{
			fi.push_back(-1);//m是栈中元素个数，元素储存在1~m之间 
		}
		else if(str[1]=='u')
		{
			scanf("%d",&te);
			fi.push_back(te);
			if(te>max)max=te;
		}
		else
		{
			fi.push_back(0);
		}
	}
	k=sqrt(max);
	vector<int> t(k+2,0);
	vector<vector<int>> b(k+2,vector<int>(k+2,0));
	for(i=0;i<=n-1;i++)
	{
		if(fi[i]==-1)
		{
			if(m==0)re.push_back(-1);//m是栈中元素个数，元素储存在1~m之间 
			else
			{
				j=ve[m]/k;//列 
				l=ve[m]%k;//行 
				b[l][j]--;
				t[j]--;
				re.push_back(ve[m]);
				m--;
				ve.pop_back();
			}
		}
		else if(fi[i]>0)
		{
			m++;
			ve.push_back(fi[i]);
			j=ve[m]/k;
			l=ve[m]%k;
			b[l][j]++;
			t[j]++;
		}
		else
		{
			if(!m)re.push_back(-1);
			else{
				find=(m+1)/2;
				sum=0;
				for(g=0;g<=k+1;g++)
				{
					sum=sum+t[g];
					if(sum>=find)break;
				}
				sum=sum-t[g];
				for(j=0;j<=k+1;j++)
				{
					sum=sum+b[j][g];
					if(sum>=find)break;
				}
				re.push_back(g*k+j);
			}
		}
	}
	for(i=0;i<=re.size()-1;i++)
	if(re[i]==-1)printf("Invalid\n");
	else printf("%d\n",re[i]);
	return 0;
}
/*
27
Pop
PeekMedian
Push 3
PeekMedian
Push 2
PeekMedian
Push 9
Push 6
PeekMedian
Pop
Push 7
Push 8
PeekMedian
Pop
PeekMedian
Push 1
PeekMedian
Pop
Pop
Push 5
Push 4
Pop
PeekMedian
Pop
Pop
Pop
Pop

out:
Invalid
Invalid
3
2
3
6
7
8
3
3
1
7
4
3
5
9
2
3
*/
