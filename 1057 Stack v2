//https://pintia.cn/problem-sets/994805342720868352/problems/994805417945710592
//使用树状数组+二分查找，应该是最好的方法之一
#include<cstdio>
#include<vector>
using namespace std;
int lb(int x)
{
	return -x&x;
}
class BIT{
	private:
		int *e;
		int size;
	public:
		BIT(int size0):size(size0+1){
			e=new int[size];
			for(int i=0;i<=size-1;i++)
			e[i]=0;
		}
		void gx(int pos,int v)
		{
			if(!pos||!v)return;
			while(pos<=size)
			{
				e[pos]=e[pos]+v;
				pos=pos+lb(pos);
			}
		}
		int gsum(int pos)
		{
			int sum=0;
			while(pos>0){
				sum=sum+e[pos];
				pos=pos-lb(pos);
			}
			return sum;
		}
		int gmid(int m,int max)
		{
			int l=1,r=max,index=(m+1)/2,mid;
			while(l<r){
				mid=(l+r)/2;
				if(gsum(mid)<index)l=mid+1;
				else r=mid;
			}
			return l;
		}
		~BIT(){
			delete[] e;
		}
};
int main()
{
	int n,i,te,max=0,m=0,j,k;
	scanf("%d",&n);
	vector<int> ve(1,0);
	vector<int> re;
	vector<int> fi;
	char str[11];
	for(i=1;i<=n;i++)
	{
		scanf("%s",str);
		if(str[1]=='o')
		{
			fi.push_back(-1);//m是栈中元素个数，元素储存在1~m之间 
			
		}
		else if(str[1]=='u')
		{
			scanf("%d",&te);
			fi.push_back(te);
			if(te>max)max=te;
		}
		else
		{
			fi.push_back(0);
		}
	}
	BIT b(max+1);
	for(i=0;i<=n-1;i++)
	{
		if(fi[i]==-1)
		{
			if(m==0)re.push_back(-1);//m是栈中元素个数，元素储存在1~m之间 
			else
			{
				re.push_back(ve[m]);
				b.gx(ve[m],-1);
				m--;
				ve.pop_back();
			}
		}
		else if(fi[i]>0)
		{
			m++;
			ve.push_back(fi[i]);
			b.gx(ve[m],1);
		}
		else
		{
			if(!m)re.push_back(-1);
			else
			re.push_back(b.gmid(m,max));
		}
	}
	for(i=0;i<=re.size()-1;i++)
	if(re[i]==-1)printf("Invalid\n");
	else printf("%d\n",re[i]);
	return 0;
}
/*
17
Pop
PeekMedian
Push 3
PeekMedian
Push 2
PeekMedian
Push 1
PeekMedian
Pop
Pop
Push 5
Push 4
PeekMedian
Pop
Pop
Pop
Pop
*/
